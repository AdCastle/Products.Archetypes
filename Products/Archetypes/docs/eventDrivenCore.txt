==============================
Event Driven Core
==============================

:Author: Benjamin Saller
:Contact: bcsaller@objectrealms.net
:Date: 2005-03-21 12:00:00 -0400 (Mon, 21 Mar 2005) 
:Web site: http://sourceforge.net/projects/archetypes


This is the working design specification and documentation for the
event driven core of Archetypes 1.x. The goal is to allow
customization of behavior without changes to the core library. We do
this by issuing events from key operations that effectively launch
chains of actions associated with listeners. Configuring additional
listeners add additional behavior.




Main Design 
==================

In the pre-1.4 Archetypes framework extensions to the core of the
system where required to add new functionally that could apply to all
the types in the system. This meant either changing the core (which
can result in feature creep, instability, unmanaged complexity, etc)
or writing custom products that overrode the medium-high level
building blocks of Archetype objects like fields. New field types
could encapsulate new behavior at the cost of redoing the Schema
definition for existing types. This often means the developer ends up
carrying new version of existing types (often in new products) to
support the addition of new behavior.

Whats needed is a simpler way to add and define new behaviors on
Archetypes. By adding events to the underlying system and triggering
behavior based on those events we can do this.

The idea is illustrated in the code below.

>>> eventually = self.portal.eventually

This is the Event Service used both in Plone and Archetypes. We are
going to create an event channel for this example and show how
functionality might be bound back into and object when its fired. We
are using the event system as a callback mechanism related to those
found in many GUI programming environments. 

>>> channel = eventually.createEventChannel("demo")

Event channels ignore events by default. To tell this event channel
that we want to to accept all incoming events for its subscribers we
set its __call__ method (which is a boolean conditional guard method)
to always return True.

>>> channel.__call__ = lambda x: True

Once the event channel has been created we can bind a listener to
it. In this case we are going to define and use a simple function. In
practice the listener would typically be a method on a service object.

>>> def doubler(event):
...    event.data['value'] *= 2

>>> eventually.subscribeToEventChannel("demo", doubler)

Now when something triggers an event on the "demo" channel we expect
the doubler callback to be triggered. Lets create a mock object that
can trigger this functionality.

>>> class MockAT:
...     value = 10
...
...     def getValue(self):
...	    event = eventually.notifyEventChannel( "demo", self, 
...                                                {'value' : self.value, } 
...                                              )
...         return event.data['value']

>>> mockAT = MockAT()
>>> assert mockAT.getValue() == 20

As you can see the value stored in the object has been doubled by the
listener on the event channel. The core of the new system is based
around this idea. When you can arrange for ordered event delivery to a
collection of callbacks we can implement additional behavior through a
single hook method.


For example Field.get might be modeled as:

 class Field:
   def get(self, instance):
      event = instance.eventually.fireEvent(self,
	    	    		            ATGetEvent(instance=instance,
					               field=field)
                                           )
      return event.data['value']
						
In this instance all of the behavior has been pushed into callbacks
and service handlers. Deciding how the object implements gets now
delegates to the event dispatcher which can implement any policy we
choose. Field gets and sets become much simpler, the framework itself
needs to carry less code, infact nearly no code, just the hooking
interfaces that services will implement to manipulate the objects.

To be clear about some elements of the Field example above. The
event.data['value'] is a product of a contract between the event type,
in this case "ATGetEvent", and the services that consume that
event. In a get operation like the above the first listener we would
expect to respond might be the "storage" service which could set the
value into the event according to the contract. If this field or
instance had other event listeners bound to it, such as filtering,
those might be called next.

While the core implementation of the Archetypes metamodel of Schemas
and Fields will get quite a bit simpler the framework will have to
carry a number of additional complexities inorder to support the
feature set we need.

The policy Engine is the system used to get policy and configuration
in and out of the system and is covered in another document. See [policyEngine]


.. policyEngine policyEngine.txt

