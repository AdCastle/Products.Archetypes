=======================
Schema provider support
=======================

As of Archetypes 1.5, it's possible to compose an object's schema from 
more than just the 'schema' class-variable. This file will test and describe
that functionality.
  
First, we create a fictional content type.
    
  >>> from zope.interface import Interface, implements
  >>> from zope.component import adapts
  
  >>> class IMyType(Interface):
  ...     pass
  
  >>> from Products.Archetypes.atapi import *
  >>> class MyType(BaseContent):
  ...     implements(IMyType)
  >>> registerType(MyType, 'testing')
  
Note that this type still has the schema from BaseSchema.

  >>> MyType.schema == BaseSchema
  True
  
We won't call Schema() yet, though - more on that in a second. There would be
no problem with defining our own schema using the 'schema' class-variable, but
for the sake of demonstration, let's show how it may be extended using an
adapter instead.
  
  >>> from Products.Archetypes.interfaces import ISchemaProvider
  >>> from Products.Archetypes.interfaces import ISchemaComposer
  
  >>> class MySchemaProvider(object):
  ...     implements(ISchemaProvider)
  ...     adapts(IMyType, ISchemaComposer)
  ...
  ...     order = 10
  ...
  ...     def __init__(self, context, composer):
  ...         self.context = context
  ...         self.composer = composer
  ...
  ...     def __call__(self, current=None):
  ...         schema = Schema((StringField('bar'),))
  ...         if current is not None:
  ...             return current + schema
  ...         else:
  ...             return schema
  
  >>> from zope.component import provideAdapter
  >>> provideAdapter(MySchemaProvider, name='my.schema')
  
Here, we have registered a named adapter, adapting our content type and the
general schema composer. We could provide a more specific composer and 
register a more specific provider - the default composer finds all adapters
providing ISchemaProvider, sorts them and then applies them in order, which
is probably fine for most cases. The 'order' is just an integer; the action
happens in __call__, which extends the current (previous-order provider's)
schema.

Now we can create an instance of our fictional content type and verify that
the schema extended schema has been applied:

  >>> m = MyType('id')
  
  >>> from Acquisition import aq_base
  >>> schema = aq_base(m.Schema())
  >>> 'title' in schema # from BaseSchema
  True
  >>> 'foo' in schema
  False
  >>> 'bar' in schema # from MySchemaProvider
  True
  
Now, could set a different base schema or offer another schema provider. 
However, for performance reasons, these won't take effect until the schema is
invalidated.
  
  >>> m.schema = BaseSchema.copy() + Schema((IntegerField('baz'),))
  
  >>> from Products.Archetypes.interfaces import IBaseObject
  >>> class GlobalSchemaProvider(object):
  ...     implements(ISchemaProvider)
  ...     adapts(IBaseObject, ISchemaComposer)
  ...
  ...     order = 20
  ...
  ...     def __init__(self, context, composer):
  ...         self.context = context
  ...         self.composer = composer
  ...
  ...     def __call__(self, current=None):
  ...         schema = Schema((StringField('foo'),))
  ...         if current is not None:
  ...             return current + schema
  ...         else:
  ...             return schema
  
  >>> provideAdapter(GlobalSchemaProvider, name='my.globalSchema')
  
Notice how this schema provider is registered for IBaseObject - it would
therefore affect any-and-all content types.
  
  >>> schema = aq_base(m.Schema())
  >>> 'foo' in schema
  False
  >>> 'bar' in schema
  True
  >>> 'baz' in schema
  False
  
The schema can be invalidated (and thus re-initialised) by firing an 
ISchemaInvalidatedEvent event.
  
  >>> from zope.event import notify
  >>> from Products.Archetypes.Schema.registry import SchemaInvalidatedEvent
  >>> notify(SchemaInvalidatedEvent(m.__class__))
  
Now the new schema should be in effect:
  
  >>> schema = aq_base(m.Schema())
  >>> 'foo' in schema
  True
  >>> 'bar' in schema
  True
  >>> 'baz' in schema
  True
  
Note that accessors and mutators also work on the extended schema.
  
  >>> m.setBar('one')
  >>> m.getBar()
  'one'
  >>> m.getRawBar()
  'one'
  
We need to clean up after ourselves:

  >>> from zope.component import getSiteManager
  >>> sm = getSiteManager()
  >>> sm.unregisterAdapter(provided=ISchemaProvider, name=u'my.globalSchema')
  True